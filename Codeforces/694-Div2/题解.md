[Contest](https://codeforces.com/contest/1471/)

## A - Strange Partition

题意：给一个数组，可以进行**将两个数以他们的和代替**的操作任意次，求数组中每个数⌈Ai / x⌉得到的最大最小值。

```c++
⌈tmp / x⌉ = tmp%x==0 ? tmp/x : tmp/x + 1
```

## B - [Strange List](https://codeforces.com/contest/1471/problem/B)

吐了，从B题就出不会了，暴力直接T了。

**题意** ：给一个数组，让你进行一个操作，最后求出操作后**最终数组的所有数的总和**。那个操作是这样的：从数组的第一个num开始，如果num可以被x整除，就在数组后面添加x个num/x,否则操作停止。

**思路** ： 可以发现，后面添加的x个num/x的和还是num。。。因此就不用很憨批地真的把所有数都加上去了。我们可以求出每个数的操作次数m，标记出最小的这个，他前面的操作数都是m+1，本身和之后的都是m，同时操作次数也就是加和时乘的数。

**举例**：

所给数组4个元素，x = 2:

```
4 2
4 6 8 2
```

{4,6,8,2} 对应的操作数为 ： {3,2,4,2},因此m = 2,标记为arr[1].

答案 = arr[0] * (m+1) + (arr[1] + arr[2] + arr[3]) * m;

## C - [Strange Birthday Party](https://codeforces.com/contest/1471/problem/C)

**题意**：给两个数组，举例：K[5] = {2 3 4 3 2} 和 递增数组C[4] = {3 5 12 20},对于每个K[i],只能买C[0] 到 C[K[i]]中的任意一个礼物，或者直接给C[K[i]]的钱数，而且每个礼物只能买一次，问最少花费多少钱。

**思路**：因为C数组是递增的所以礼物尽可能从C数组的前面选起，不能再选了就花当前C[K[i]]的价钱。

举例上述数组的做法：先将K数组排序为{4 3 3 2 2},

i = 0 第一个为4，ans += C[i]

i = 1第二个为3，ans += C[i]

i = 2第三个为3，因为 i+1 >= C[i] 了，从此之后 ans += C[K[i]]

i = 3第四个为2，ans += C[K[i]]

i = 4第五个为2，ans += C[K[i]]

于是ans = 3 + 5 + 12 + 5 + 5.

